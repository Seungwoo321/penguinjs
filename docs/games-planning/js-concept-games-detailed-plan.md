# JavaScript 개념별 학습 게임 상세 기획

## 게임 컬렉션 개요
각 JavaScript 개념의 특성에 맞는 다양한 형태의 인터랙티브 학습 게임

---

## 1. 🐸 Closure Cave (클로저 동굴)

### 게임 타입: **Flexbox Froggy 스타일 - 코드 작성**
- **테마**: 보물 사냥꾼이 동굴 탐험
- **목표**: 클로저를 활용하여 보물상자에 접근

### 게임플레이
- 함수 스코프를 동굴로, 클로저를 비밀 통로로 표현
- 플레이어가 코드를 작성하여 올바른 클로저 생성
- 보물상자(변수)에 접근하는 경로 시각화

### 스테이지 구성
**🟢 Beginner (5 stages)**
- 기본 함수 스코프 이해
- 간단한 클로저 만들기
- 외부 변수 접근하기
- 카운터 클로저 구현
- 클로저로 데이터 보호

**🟡 Intermediate (5 stages)**
- 반복문 안의 클로저
- 즉시실행함수와 클로저
- 고차함수 클로저
- 모듈 패턴
- 클로저 메모리 누수 해결

**🔴 Advanced (5 stages)**
- 복잡한 중첩 클로저
- 클로저와 this 바인딩
- 클로저 성능 최적화
- 실무 패턴 적용
- 클로저 디버깅

---

## 2. 📚 CallStack Library (콜스택 도서관)

### 게임 타입: **드래그 앤 드롭 시뮬레이션**
- **테마**: 도서관에서 책을 쌓고 정리하기
- **목표**: 함수 호출 순서를 책 더미로 시각화

### 게임플레이
- 주어진 코드를 실행하면 책들이 자동으로 쌓임
- 각 함수 호출마다 새로운 책이 추가
- 함수 종료시 맨 위 책이 사라짐
- 플레이어가 실행 순서를 예측하고 확인

### 스테이지 구성
**🟢 Beginner (5 stages)**
- 단순 함수 호출 순서
- 함수 내 함수 호출
- 기본 재귀 함수
- 콜스택 크기 이해
- 스택 오버플로우 체험

**🟡 Intermediate (5 stages)**
- 복잡한 재귀 패턴
- 상호 재귀 함수
- 비동기 함수와 콜스택
- 에러 스택 추적
- 최적화 기법

**🔴 Advanced (5 stages)**
- 깊은 재귀 최적화
- 꼬리 재귀 최적화
- 스택 메모리 관리
- 디버깅 전략
- 성능 프로파일링

---

## 3. 🎮 Promise Battle (프로미스 배틀)

### 게임 타입: **턴제 카드 게임**
- **테마**: Promise 상태를 카드로 표현
- **목표**: 올바른 Promise 체인으로 상대를 이기기

### 게임플레이
- 플레이어가 카드 조합으로 Promise 체인 구성
- 상대방(AI 또는 다른 플레이어)과 턴제 대전
- 올바른 Promise 체인을 먼저 완성하는 사람이 승리

### 카드 종류
- **Pending**: 대기 상태 (회색 카드)
- **Resolved**: 성공 (녹색 카드) 
- **Rejected**: 실패 (빨간 카드)
- **Then**: 체이닝 (파란 카드)
- **Catch**: 에러 처리 (주황 카드)

### 스테이지 구성
**🟢 Beginner (5 stages)**
- 기본 Promise 생성
- then 체이닝
- catch 에러 처리
- Promise 상태 이해
- 간단한 체인 구성

**🟡 Intermediate (5 stages)**
- Promise.all 동시 처리
- Promise.race 경쟁
- 복잡한 체이닝
- 에러 전파 이해
- finally 블록 활용

**🔴 Advanced (5 stages)**
- 커스텀 Promise 구현
- Promise 병렬/순차 조합
- 에러 복구 패턴
- Promise 취소 구현
- 실무 패턴 적용

---

## 4. 🛫 Async Airways (비동기 항공사)

### 게임 타입: **실시간 스케줄 관리**
- **테마**: 공항 관제탑에서 비행기 스케줄 관리
- **목표**: async/await로 효율적인 항공편 운영

### 게임플레이
- 동시에 여러 비행기가 이착륙 요청
- 플레이어가 async/await 구문을 작성하여 순서 결정
- 연료, 날씨 등 변수를 고려한 스케줄링

### 학습 효과
- 순차 vs 병렬 실행 차이점
- await의 블로킹 특성 이해
- Promise.all을 통한 병렬 처리

---

## 5. 🪞 Proxy Laboratory (프록시 실험실)

### 게임 타입: **퍼즐/실험 시뮬레이션**
- **테마**: 과학자가 객체의 행동을 관찰하고 조작
- **목표**: Proxy 핸들러로 객체 동작 변경하기

### 게임플레이
- 실험 대상 객체가 주어짐
- 플레이어가 get, set, has 등의 핸들러 작성
- 기대하는 결과와 실제 결과 비교

### 학습 효과
- 메타프로그래밍 개념 이해
- 각 핸들러의 역할과 용도

---

## 6. 🎯 Event Target (이벤트 타겟)

### 게임 타입: **Flexbox Froggy 스타일 - 위치 맞추기**
- **테마**: 이벤트를 올바른 타겟에 배치하기
- **목표**: CSS 선택자로 이벤트 리스너를 정확한 요소에 연결

### 게임플레이
```css
/* 플레이어가 작성하는 코드 */
.button { /* 버튼에 클릭 이벤트 연결 */ }
.container > div { /* 자식 div에만 이벤트 적용 */ }
```

### 레벨 예시
- 특정 버튼만 클릭 가능하게 만들기
- 이벤트 버블링 막기
- 이벤트 위임으로 동적 요소 처리

---

## 7. 🔗 Prototype Chain (프로토타입 체인)

### 게임 타입: **연결 퍼즐**
- **테마**: 상속 관계를 선으로 연결하기
- **목표**: 올바른 프로토타입 체인 구성

### 게임플레이
- 화면에 흩어진 객체들
- 플레이어가 드래그로 상속 관계 연결
- 메서드 호출 시 체인을 따라 검색하는 과정 시각화

### 학습 효과
- 프로토타입 체인 탐색 과정
- 메서드 오버라이딩 개념

---

## 8. 🎬 EventLoop Cinema (이벤트 루프 영화관)

### 게임 타입: **타이밍 기반 액션**
- **테마**: 영화관에서 올바른 순서로 영화 상영하기
- **목표**: 실행 순서 예측하고 맞추기

### 게임플레이
```javascript
console.log('1');
setTimeout(() => console.log('2'), 0);
Promise.resolve().then(() => console.log('3'));
console.log('4');

// 플레이어가 출력 순서를 예측: 1, 4, 3, 2
```

### 인터랙션
- 코드 실행 전 순서 예측하여 번호 배치
- 실제 실행과 비교하여 점수 획득
- 복잡도가 점진적으로 증가

### 학습 효과
- 마이크로태스크 우선순위 이해
- 이벤트 루프의 작동 원리

---

## 9. 🧠 Memory Management Museum (메모리 관리 박물관)

### 게임 타입: **관리 시뮬레이션**
- **테마**: 박물관 큐레이터가 전시품 관리
- **목표**: 가비지 컬렉션으로 메모리 효율적 관리

### 게임플레이
- 전시품(객체)들이 계속 추가됨
- 참조가 없어진 전시품을 자동/수동으로 제거
- 메모리 사용량을 최적화하여 박물관 운영

### 스테이지 구성
**🟢 Beginner (5 stages)**
- 기본 객체 생성과 소멸
- 참조 카운팅 이해
- 순환 참조 발견
- WeakMap 활용
- 메모리 누수 방지

**🟡 Intermediate (5 stages)**
- DOM 노드 메모리 관리
- 이벤트 리스너 정리
- 클로저와 메모리
- 타이머 정리
- 대용량 데이터 처리

**🔴 Advanced (5 stages)**
- 메모리 프로파일링
- 성능 최적화 패턴
- 브라우저별 GC 특성
- 메모리 풀 관리
- 실무 최적화 사례

---

## 10. 🌳 Scope Forest (스코프 숲)

### 게임 타입: **탐험/퍼즐**
- **테마**: 숲 속에서 보물 찾기
- **목표**: 스코프 체인을 따라 변수에 접근

### 게임플레이
- 각 나무(함수)마다 다른 층의 보물(변수)
- 플레이어가 올바른 경로로 보물에 접근
- 스코프 체인 시각화로 탐색 과정 표시

### 스테이지 구성
**🟢 Beginner (5 stages)**
- 전역 스코프 탐색
- 함수 스코프 이해
- 블록 스코프 구분
- 중첩 함수 스코프
- 스코프 체인 기본

**🟡 Intermediate (5 stages)**
- 복잡한 중첩 스코프
- 스코프와 호이스팅
- 모듈 스코프
- with 문 (deprecated)
- 동적 스코프 vs 정적 스코프

**🔴 Advanced (5 stages)**
- 스코프 최적화
- 메모리와 스코프
- 실행 컨텍스트 연동
- 성능 고려사항
- 고급 패턴 활용

---

## 11. ⚡ Hoisting Helicopter (호이스팅 헬리콥터)

### 게임 타입: **물리 시뮬레이션**
- **테마**: 헬리콥터로 화물 운반
- **목표**: 선언과 할당을 올바른 높이에 배치

### 게임플레이
- var, let, const 화물을 적절한 높이로 운반
- 호이스팅 규칙에 따라 화물이 자동으로 이동
- TDZ(Temporal Dead Zone) 구역 표시

### 스테이지 구성
**🟢 Beginner (5 stages)**
- var 호이스팅 기본
- 함수 호이스팅
- 선언 vs 할당 구분
- undefined vs ReferenceError
- 기본 호이스팅 패턴

**🟡 Intermediate (5 stages)**
- let/const 호이스팅
- TDZ 개념과 활용
- 함수 표현식 vs 선언식
- 클래스 호이스팅
- 모듈 호이스팅

**🔴 Advanced (5 stages)**
- 복잡한 호이스팅 시나리오
- 호이스팅과 스코프 상호작용
- 최적화와 호이스팅
- 실무 패턴과 주의사항
- 디버깅 전략

---

## 12. 🎯 This Binding Target (this 바인딩 타겟)

### 게임 타입: **타겟 슈팅**
- **테마**: 화살로 정확한 타겟 맞추기
- **목표**: 다양한 상황에서 this가 가리키는 대상 예측

### 게임플레이
- 화살(this)이 어떤 타겟을 향하는지 예측
- call, apply, bind로 타겟 변경
- 화살표 함수의 특별한 동작 표현

### 스테이지 구성
**🟢 Beginner (5 stages)**
- 전역 this
- 객체 메서드의 this
- 함수 호출 시 this
- 생성자 함수 this
- 이벤트 핸들러 this

**🟡 Intermediate (5 stages)**
- call/apply/bind 활용
- 화살표 함수와 this
- 중첩 함수의 this
- 콜백 함수의 this
- 클래스 메서드 this

**🔴 Advanced (5 stages)**
- 복잡한 this 바인딩
- this와 클로저 조합
- 프록시와 this
- 성능 최적화
- 실무 패턴과 우회법

---

## 13. 🎪 Destructuring Circus (구조분해 서커스)

### 게임 타입: **퍼즐/패턴 매칭**
- **테마**: 서커스 공연자를 올바른 위치에 배치
- **목표**: 복잡한 데이터를 적절한 변수로 분해

### 게임플레이
- 배열과 객체가 서커스 무대에 등장
- 플레이어가 구조분해 패턴으로 공연자 배치
- 중첩된 구조와 기본값 처리

### 스테이지 구성
**🟢 Beginner (5 stages)**
- 배열 구조분해 기본
- 객체 구조분해 기본
- 변수명 변경
- 기본값 설정
- 나머지 패턴

**🟡 Intermediate (5 stages)**
- 중첩 구조분해
- 함수 매개변수 구조분해
- 스왑과 교환
- 동적 속성명
- 계산된 속성

**🔴 Advanced (5 stages)**
- 복잡한 중첩 패턴
- 성능 고려사항
- 타입스크립트와 구조분해
- 실무 활용 패턴
- 최적화 기법

---

## 14. 🔄 Array Methods Racing (배열 메서드 레이싱)

### 게임 타입: **레이싱/경쟁**
- **테마**: 자동차 경주에서 코스 선택
- **목표**: 상황에 맞는 최적의 배열 메서드 선택

### 게임플레이
- 각 배열 메서드가 다른 특성의 자동차
- 주어진 미션에 따라 적절한 메서드 선택
- 성능과 결과를 고려한 최적 경로 찾기

### 스테이지 구성
**🟢 Beginner (5 stages)**
- map으로 변환하기
- filter로 필터링
- reduce로 집계
- forEach로 순회
- find로 검색

**🟡 Intermediate (5 stages)**
- 메서드 체이닝
- some/every 조건 검사
- sort로 정렬
- splice/slice 조작
- 성능 비교

**🔴 Advanced (5 stages)**
- 복잡한 체이닝 최적화
- 커스텀 메서드 구현
- 함수형 프로그래밍 패턴
- 대용량 데이터 처리
- 실무 최적화 사례

---

## 15. 🎲 Modules Marketplace (모듈 마켓플레이스)

### 게임 타입: **경영 시뮬레이션**
- **테마**: 상점에서 필요한 상품 주문하고 판매
- **목표**: 모듈 시스템으로 효율적인 코드 구성

### 게임플레이
- 다른 상점(모듈)에서 상품(함수/클래스) 주문
- 자신의 상품을 다른 상점에 공급
- 순환 의존성과 모듈 최적화 관리

### 스테이지 구성
**🟢 Beginner (5 stages)**
- 기본 import/export
- default export
- named export
- 모듈 경로 이해
- 브라우저 모듈

**🟡 Intermediate (5 stages)**
- 동적 import
- re-export 패턴
- 모듈 번들링
- CommonJS vs ES Modules
- 트리 쉐이킹

**🔴 Advanced (5 stages)**
- 순환 의존성 해결
- 모듈 페더레이션
- 성능 최적화
- 마이크로 프론트엔드
- 실무 아키텍처 패턴

---

## 16. 🎨 Template Literal Art (템플릿 리터럴 아트)

### 게임 타입: **창작/아트**
- **테마**: 디지털 아티스트가 그림 그리기
- **목표**: 템플릿 리터럴로 동적 문자열 생성

### 게임플레이
- 변수와 표현식을 조합하여 아트워크 완성
- 태그드 템플릿으로 특수 효과 적용
- 다국어 지원과 포맷팅

### 스테이지 구성
**🟢 Beginner (5 stages)**
- 기본 문자열 보간
- 표현식 삽입
- 멀티라인 문자열
- 이스케이프 처리
- 기본 포맷팅

**🟡 Intermediate (5 stages)**
- 태그드 템플릿 기본
- 조건부 문자열 생성
- 반복 패턴 생성
- HTML 템플릿
- CSS 동적 생성

**🔴 Advanced (5 stages)**
- 고급 태그드 템플릿
- 보안 고려사항 (XSS 방지)
- 성능 최적화
- 국제화 패턴
- 템플릿 엔진 구현

---

## 17. 🔧 Error Handling Hospital (에러 처리 병원)

### 게임 타입: **의료 시뮬레이션**
- **테마**: 응급실에서 다양한 환자 치료
- **목표**: 적절한 에러 처리로 안정적인 프로그램 구현

### 게임플레이
- 다양한 에러 타입의 환자가 병원에 도착
- 적절한 try/catch/finally 처방으로 치료
- 에러 예방과 복구 전략 수립

### 스테이지 구성
**🟢 Beginner (5 stages)**
- 기본 try/catch 사용
- Error 객체 이해
- finally 블록 활용
- 에러 타입 구분
- 기본 에러 메시지

**🟡 Intermediate (5 stages)**
- 커스텀 에러 클래스
- 에러 전파와 버블링
- async/await 에러 처리
- Promise 에러 처리
- 에러 로깅 전략

**🔴 Advanced (5 stages)**
- 글로벌 에러 핸들러
- 에러 복구 패턴
- 모니터링과 알림
- 사용자 경험 고려
- 실무 에러 처리 전략

---

## 18. 🎯 WeakMap/WeakSet Vault (약한 참조 금고)

### 게임 타입: **보안/스파이**
- **테마**: 첨단 보안 시설에서 임시 보안 키 관리
- **목표**: WeakMap/WeakSet의 특성을 활용한 메모리 효율적 관리

### 게임플레이
- 보안 키(객체)가 사라지면 자동으로 접근 권한 소멸
- 일반 Map/Set과의 차이점 체험
- 메모리 누수 없는 캐시 시스템 구축

### 스테이지 구성
**🟢 Beginner (5 stages)**
- WeakMap 기본 사용법
- WeakSet 기본 사용법
- Map vs WeakMap 차이
- 가비지 컬렉션 체험
- 기본 활용 패턴

**🟡 Intermediate (5 stages)**
- 프라이빗 데이터 저장
- 캐시 시스템 구현
- DOM 노드와 WeakMap
- 이벤트 핸들러 관리
- 메타데이터 저장

**🔴 Advanced (5 stages)**
- 고급 디자인 패턴
- 성능 최적화
- 메모리 프로파일링
- 실무 활용 사례
- 아키텍처 설계

---

## 게임 공통 기능

### 진행도 시스템
- 각 게임당 10-15레벨
- 별점 시스템 (1-3개별)
- 전체 진행률 트래킹

### 힌트 시스템
- 단계별 힌트 제공
- 코드 실행 과정 시각화
- MDN 문서 연결

### 코드 에디터
- 구문 강조
- 자동 완성
- 실시간 오류 검사

### 시각화 엔진
- CSS 애니메이션 기반
- 단계별 실행 과정 표시
- 인터랙티브 요소

## 기술 스택

### 프론트엔드
- **바닐라 JavaScript**: 게임 로직
- **CSS3 + Animations**: 시각화
- **HTML5**: 마크업
- **CodeMirror**: 코드 에디터

### 구조
```
📁 js-concept-games/
├── 📁 games/
│   ├── 📁 closure-cave/
│   ├── 📁 callstack-tower/
│   ├── 📁 promise-rocket/
│   └── ...
├── 📁 shared/
│   ├── 📄 game-engine.js
│   ├── 📄 visualizer.js
│   └── 📄 code-runner.js
└── 📄 index.html
```

### 개발 단계
1. **Week 1-2**: 게임 엔진과 공통 컴포넌트 개발
2. **Week 3-4**: Closure Cave 프로토타입 구현
3. **Week 5-6**: CallStack Tower, Promise Rocket 추가
4. **Week 7-8**: 나머지 게임들 구현
5. **Week 9-10**: 통합, 테스트, 최적화