# JavaScript 개념별 학습 게임 상세 기획

## 게임 컬렉션 개요
각 JavaScript 개념의 특성에 맞는 다양한 형태의 인터랙티브 학습 게임

---

## 1. 🐸 Closure Cave (클로저 동굴)

### 게임 타입: **Flexbox Froggy 스타일 - 코드 작성**
- **테마**: 보물 사냥꾼이 동굴 탐험
- **목표**: 클로저를 활용하여 보물상자에 접근

### 게임플레이
- 함수 스코프를 동굴로, 클로저를 비밀 통로로 표현
- 플레이어가 코드를 작성하여 올바른 클로저 생성
- 보물상자(변수)에 접근하는 경로 시각화

### 스테이지 구성
**🟢 Beginner (5 stages)**
- 기본 함수 스코프 이해
- 간단한 클로저 만들기
- 외부 변수 접근하기
- 카운터 클로저 구현
- 클로저로 데이터 보호

**🟡 Intermediate (5 stages)**
- 반복문 안의 클로저
- 즉시실행함수와 클로저
- 고차함수 클로저
- 모듈 패턴
- 클로저 메모리 누수 해결

**🔴 Advanced (5 stages)**
- 복잡한 중첩 클로저
- 클로저와 this 바인딩
- 클로저 성능 최적화
- 실무 패턴 적용
- 클로저 디버깅

---

## 2. 📚 CallStack Library (콜스택 도서관)

### 게임 타입: **드래그 앤 드롭 시뮬레이션**
- **테마**: 도서관에서 책을 쌓고 정리하기
- **목표**: 함수 호출 순서를 책 더미로 시각화

### 게임플레이
- 주어진 코드를 실행하면 책들이 자동으로 쌓임
- 각 함수 호출마다 새로운 책이 추가
- 함수 종료시 맨 위 책이 사라짐
- 플레이어가 실행 순서를 예측하고 확인

### 스테이지 구성
**🟢 Beginner (5 stages)**
- 단순 함수 호출 순서
- 함수 내 함수 호출
- 기본 재귀 함수
- 콜스택 크기 이해
- 스택 오버플로우 체험

**🟡 Intermediate (5 stages)**
- 복잡한 재귀 패턴
- 상호 재귀 함수
- 비동기 함수와 콜스택
- 에러 스택 추적
- 최적화 기법

**🔴 Advanced (5 stages)**
- 깊은 재귀 최적화
- 꼬리 재귀 최적화
- 스택 메모리 관리
- 디버깅 전략
- 성능 프로파일링

---

## 3. 🎮 Promise Battle (프로미스 배틀)

### 게임 타입: **턴제 카드 게임**
- **테마**: Promise 상태를 카드로 표현
- **목표**: 올바른 Promise 체인으로 상대를 이기기

### 게임플레이
- 플레이어가 카드 조합으로 Promise 체인 구성
- 상대방(AI 또는 다른 플레이어)과 턴제 대전
- 올바른 Promise 체인을 먼저 완성하는 사람이 승리

### 카드 종류
- **Pending**: 대기 상태 (회색 카드)
- **Resolved**: 성공 (녹색 카드) 
- **Rejected**: 실패 (빨간 카드)
- **Then**: 체이닝 (파란 카드)
- **Catch**: 에러 처리 (주황 카드)

### 스테이지 구성
**🟢 Beginner (5 stages)**
- 기본 Promise 생성
- then 체이닝
- catch 에러 처리
- Promise 상태 이해
- 간단한 체인 구성

**🟡 Intermediate (5 stages)**
- Promise.all 동시 처리
- Promise.race 경쟁
- 복잡한 체이닝
- 에러 전파 이해
- finally 블록 활용

**🔴 Advanced (5 stages)**
- 커스텀 Promise 구현
- Promise 병렬/순차 조합
- 에러 복구 패턴
- Promise 취소 구현
- 실무 패턴 적용

---

## 4. 🛫 Async Airways (비동기 항공사)

### 게임 타입: **실시간 관제 시뮬레이션**
- **테마**: 바쁜 국제공항의 항공 관제사가 되어 비행기들을 안전하게 관리
- **목표**: async/await를 마스터하여 완벽한 항공 스케줄 운영

### 게임플레이
- 관제탑 레이더 화면에서 실시간으로 비행기들이 접근
- 각 비행기마다 연료량, 승객 수, 날씨 상황이 다름
- 플레이어가 async/await 코드를 작성하여 착륙 순서와 타이밍 결정
- 동시 처리 vs 순차 처리의 전략적 선택이 핵심
- 성공적인 착륙시 점수 획득, 실패시 사고로 인한 점수 차감

### 항공기 종류
- **🛩️ 경량기**: 빠른 처리, 낮은 연료 소모
- **✈️ 여객기**: 보통 처리 시간, 많은 승객
- **🚁 헬리콥터**: 응급상황, 최우선 처리 필요
- **🛫 화물기**: 느린 처리, 높은 연료 소모
- **🚀 전용기**: VIP 승객, 특별 스케줄 요구

### 스테이지 구성
**🟢 Beginner (5 stages)**
- 단일 비행기 async 함수 기본
- await 키워드로 순차 착륙 처리
- Promise 기반 착륙 절차 구현
- 간단한 try/catch 에러 처리
- 기본 async/await 문법 완전 이해

**🟡 Intermediate (5 stages)**
- 다중 비행기 동시 처리 (Promise.all)
- 우선순위 기반 처리 (Promise.race)
- 복잡한 조건부 비동기 로직
- 에러 복구 및 대체 경로 시나리오
- 동적 스케줄 조정 및 최적화

**🔴 Advanced (5 stages)**
- 대규모 국제공항 시뮬레이션
- 실시간 날씨 변화 대응 로직
- 고성능 비동기 패턴 구현
- 메모리 효율적인 대용량 처리
- 실무급 항공 관제 시스템 구축

---

## 5. 🪞 Proxy Laboratory (프록시 실험실)

### 게임 타입: **과학 실험 시뮬레이션**
- **테마**: 첨단 연구소의 과학자가 되어 객체의 비밀스러운 행동을 연구
- **목표**: Proxy의 강력한 핸들러들을 마스터하여 객체를 완전히 제어

### 게임플레이
- 고급 실험실에 다양한 "실험체 객체"들이 격리되어 있음
- 각 객체마다 특별한 행동 패턴과 보안 프로토콜이 적용됨
- 플레이어가 Proxy 핸들러 코드를 작성하여 객체의 행동을 조작
- 실시간 모니터링 시스템으로 모든 접근과 변경 사항을 추적
- 실험 목표 달성시 새로운 실험체와 고급 장비 언락

### 실험 장비
- **🔬 접근 스캐너**: get 핸들러로 속성 접근 감지
- **⚗️ 변경 감지기**: set 핸들러로 속성 변경 추적
- **🧪 존재 탐지기**: has 핸들러로 속성 존재 확인
- **🔥 삭제 분석기**: deleteProperty 핸들러 활용
- **⚡ 함수 제어기**: apply/construct 핸들러로 함수 제어

### 스테이지 구성
**🟢 Beginner (5 stages)**
- 기본 속성 접근 감시 (get 핸들러)
- 속성 변경 가로채기 (set 핸들러)
- 속성 존재 여부 조작 (has 핸들러)
- 속성 삭제 방지하기 (deleteProperty 핸들러)
- 간단한 로깅 시스템 구축

**🟡 Intermediate (5 stages)**
- 중첩 객체 깊이 모니터링
- 배열 접근 패턴 분석
- 함수 호출 가로채기 (apply 핸들러)
- 생성자 호출 제어 (construct 핸들러)
- 다중 프록시 체인 구성

**🔴 Advanced (5 stages)**
- 고성능 프록시 최적화 기법
- 복잡한 메타프로그래밍 패턴 구현
- Reflect API와 프록시 완벽 조합
- 실무급 보안 프록시 시스템
- 커스텀 프레임워크 아키텍처 설계

---

## 6. 🎯 Event Target (이벤트 타겟)

### 게임 타입: **아케이드 슈팅 게임**
- **테마**: 사격수가 화살로 올바른 DOM 타겟에 이벤트를 정확히 명중시키기
- **목표**: 이벤트 시스템의 모든 측면을 마스터하여 완벽한 인터랙션 구현

### 게임플레이
- 사격장에 다양한 모양과 크기의 타겟들이 리더보드나 화살표 벤언 형태로 배치
- 플레이어가 이벤트 리스너 코드를 작성하여 화살에 정확한 타겟 지정
- 이벤트 버블링 과정을 비비하는 색깔의 원으로 시각화
- 타겟 명중 시 폭발 이팩트와 점수 획득, 실패 시 빗나간 화살
- event.target, event.currentTarget, event.relatedTarget의 차이를 실시간 표시

### 타겟 종류
- **🔴 기본 타겟**: 단일 요소, 직접 이벤트 연결
- **🟡 중첩 타겟**: 부모-자식 구조, 버블링 활용
- **🟠 동적 타겟**: 실시간 생성되는 요소, 위임 패턴
- **🔵 이벤트 캡처**: 버블링 단계에서 가로채기
- **⚫️ 어두운 타겟**: 비표준 이벤트나 커스텀 이벤트

### 스테이지 구성
**🟢 Beginner (5 stages)**
- 기본 클릭 이벤트 연결과 핸들러 작성
- 이벤트 객체 주요 속성 활용 (target, type, timeStamp)
- preventDefault()와 stopPropagation() 기초 사용
- 마우스 이벤트 종류별 처리 (click, mouseenter, mouseleave)
- 키보드 이벤트 기초 (keydown, keyup, keypress)

**🟡 Intermediate (5 stages)**
- 이벤트 버블링과 캡처링 단계 완전 이해
- 이벤트 위임 패턴으로 동적 요소 처리
- 복잡한 키보드 이벤트 조합 및 단축키
- 터치 이벤트와 제스처 인식
- 커스텀 이벤트 수신과 전파

**🔴 Advanced (5 stages)**
- 고성능 이벤트 위임 시스템 구축
- 커스텀 이벤트 생성과 디스패치 (CustomEvent)
- 이벤트 성능 최적화 및 passive 리스너
- 웹 접근성을 고려한 이벤트 처리 패턴
- 모던 이벤트 API (Intersection Observer, Mutation Observer)

---

## 7. 🔗 Prototype Chain (프로토타입 체인)

### 게임 타입: **유전자 계보 연결 퍼즐**
- **테마**: 유전학 연구소에서 객체들의 상속 계보를 올바르게 연결하기
- **목표**: 프로토타입 체인의 모든 비밀을 파헤쳐 완벽한 상속 시스템 구축

### 게임플레이
- 거대한 연구실에 다양한 "객체 생명체"들이 흩어져 있음
- 각 객체는 고유한 DNA(메서드와 속성)를 가지고 있음
- 플레이어가 드래그앤드롭으로 상속 관계를 빔나는 선으로 연결
- 메서드 호출 시 체인을 따라 올라가는 "상속 추적기" 애니메이션
- 잘못된 연결 시 전기충격과 함께 경고 메시지
- 성공적인 연결 시 아름다운 발광 효과와 유전자 전달 확인

### 생명체 종류
- **🐛 원시 생명체**: Object.prototype, 모든 생명체의 조상
- **🦆 포유류**: Array, Function 등 주요 내장 객체들
- **🐶 개체**: 사용자 정의 생성자 함수
- **🧬 변이체**: ES6 클래스와 상속
- **👾 인공체**: Object.create()로 만들어진 객체

### 스테이지 구성
**🟢 Beginner (5 stages)**
- 기본 프로토타입 개념과 __proto__ 이해
- Object.prototype에서 메서드 상속받기
- 생성자 함수와 prototype 속성 연결
- hasOwnProperty로 속성 소유 여부 확인
- 간단한 2단계 상속 구성

**🟡 Intermediate (5 stages)**
- 3단계 이상 복잡한 상속 체인 구성
- 메서드 오버라이딩과 super 개념
- Object.create()로 사용자 정의 상속 구현
- 동적 프로토타입 메서드 추가/수정
- instanceof 연산자와 체인 검사

**🔴 Advanced (5 stages)**
- 복잡한 다중 상속과 믹스인 패턴
- 프로토타입 폴루션 방지 및 보안 고려사항
- 성능 최적화된 프로토타입 설계 패턴
- ES6 클래스와 전통 프로토타입의 상호 연동
- 실무급 프로토타입 기반 아키텍처 설계

---

## 8. 🎬 EventLoop Cinema (이벤트 루프 영화관)

### 게임 타입: **실시간 예측 액션 게임**
- **테마**: 멀티플렉스 영화관의 상영 관리자가 되어 올바른 순서로 영화 상영 예약
- **목표**: 이벤트 루프의 모든 비밀을 파헤쳐 JavaScript 비동기 실행 순서 완벽 예측

### 게임플레이
- 거대한 영화관 복합건물에 여러 상영관이 동시 운영됨
- 각 상영관은 다른 영화 장르(sync, async, microtask)를 담당
- 주어진 JavaScript 코드를 보고 어떤 상영관에서 먼저 상영될지 예측
- 드래그앤드롭으로 실행 순서 번호를 상영관에 배치
- 실제 실행 결과와 비교하여 정확도에 따른 점수 및 관객 만족도 획득
- 매 단계마다 코드 복잡도와 예약 난이도 증가

### 상영관 종류
- **🟥 주 상영관**: Call Stack, 동기 코드 즉시 실행
- **🟦 VIP 상영관**: Microtask Queue, Promise.then, async/await
- **🟨 일반 상영관**: Macrotask Queue, setTimeout, setInterval
- **🟩 특별 상영관**: Web APIs, DOM 이벤트, HTTP 요청
- **🟧 예술 상영관**: Animation Frames, requestAnimationFrame

### 예시 코드 시나리오
```javascript
console.log('1'); // 주 상영관
setTimeout(() => console.log('2'), 0); // 일반 상영관
Promise.resolve().then(() => console.log('3')); // VIP 상영관
console.log('4'); // 주 상영관
// 정답: 1 → 4 → 3 → 2
```

### 스테이지 구성
**🟢 Beginner (5 stages)**
- 기본 동기 vs 비동기 실행 순서
- setTimeout과 동기 코드의 순서 예측
- Promise.then과 setTimeout의 우선순위 비교
- 간단한 콜백 함수 실행 순서
- 마이크로태스크와 매크로태스크 기초 구분

**🟡 Intermediate (5 stages)**
- 복잡한 async/await와 Promise 체인 순서
- 중첩된 setTimeout과 setInterval 조합
- DOM 이벤트와 비동기 코드의 상호작용
- requestAnimationFrame과 다른 비동기 API 조합
- 에러 처리와 Promise rejection 순서

**🔴 Advanced (5 stages)**
- 측정 불가능한 네트워크 요청과 비동기 순서
- 복잡한 중첩 비동기 패턴 분석
- 성능 최적화를 위한 비동기 순서 예측
- 브라우저별 이벤트 루프 차이점 이해
- 실무급 대규모 애플리케이션 비동기 패턴 분석

---

## 9. 🧠 Memory Management Museum (메모리 관리 박물관)

### 게임 타입: **실시간 박물관 운영 시뮬레이션**
- **테마**: 세계 최고 수준의 디지털 박물관 관장이 되어 무한정 늘어나는 전시품을 효율적으로 관리
- **목표**: 가비지 컬렉션과 메모리 관리의 모든 기법을 마스터하여 메모리 누수 없는 완벽한 박물관 운영

### 게임플레이
- 24시간 개방되는 초현대식 박물관에 끊임없이 새로운 전시품(객체)들이 기증됨
- 각 전시품마다 고유한 "참조 관계"와 "메모리 점유량"이 다름
- 플레이어가 직접 가비지 컬렉션 정책을 설계하고 메모리 정리 전략 구현
- 참조가 끊어진 전시품들을 적절한 타이밍에 창고로 이동(GC 실행)
- 순환 참조로 얽힌 전시품들을 발견하고 해결하는 특별 미션
- 메모리 사용량이 한계에 도달하면 박물관 폐쇄 위기, 효율적 관리로 방문객 만족도 극대화

### 전시품 종류
- **🏺 고전 전시품**: 기본 객체, 단순한 참조 관계
- **🖼️ 현대 미술품**: DOM 요소, 이벤트 리스너 포함
- **🎭 퍼포먼스 아트**: 함수와 클로저, 복잡한 스코프 체인
- **💎 희귀 보석**: WeakMap/WeakSet, 약한 참조
- **🎪 대형 설치작품**: 대용량 데이터 구조, 배열과 맵
- **🔗 연결 조각상**: 순환 참조 구조물

### 스테이지 구성
**🟢 Beginner (5 stages)**
- 기본 객체 생성과 참조 제거를 통한 메모리 해제
- 참조 카운팅 방식의 가비지 컬렉션 체험
- 순환 참조 문제 발견과 해결 방법
- WeakMap과 WeakSet의 기본 활용법
- 간단한 메모리 누수 패턴 인식과 방지

**🟡 Intermediate (5 stages)**
- DOM 노드와 이벤트 리스너의 메모리 관리
- 클로저 환경과 메모리 점유 관계 분석
- 타이머 함수의 적절한 정리와 해제
- 대용량 배열과 객체의 효율적 처리 전략
- 브라우저 개발자 도구를 활용한 메모리 프로파일링

**🔴 Advanced (5 stages)**
- 고급 메모리 프로파일링과 힙 스냅샷 분석
- 브라우저별 가비지 컬렉션 알고리즘 차이점 활용
- 메모리 풀과 객체 재사용 패턴 구현
- 대규모 SPA 애플리케이션의 메모리 최적화 전략
- 실무급 메모리 누수 진단과 해결 사례 연구

---

## 10. 🌳 Scope Forest (스코프 숲)

### 게임 타입: **3D 탐험 어드벤처 게임**
- **테마**: 신비로운 마법 숲의 탐험가가 되어 스코프 나무들 사이를 탐험하며 숨겨진 변수 보물을 찾기
- **목표**: 스코프 체인의 모든 비밀을 파헤쳐 완벽한 변수 접근 마스터가 되기

### 게임플레이
- 거대한 마법 숲에 각각 다른 스코프를 가진 신비로운 나무들이 자라고 있음
- 각 나무는 고유한 "스코프 층"을 가지며, 상위층에서 하위층을 내려다볼 수 있음
- 플레이어가 탐험가가 되어 올바른 스코프 경로를 따라 숨겨진 변수 보물에 접근
- 실시간 스코프 체인 추적기로 변수 검색 과정을 아름다운 빛의 경로로 시각화
- 잘못된 접근 시 "스코프 미로"에 갇히며, 올바른 경로 발견 시 마법적인 보물 발견 효과
- 레벨이 올라갈수록 더 복잡한 중첩 구조와 다양한 스코프 타입 등장

### 숨겨진 보물 종류
- **💎 전역 보석**: 전역 스코프 변수, 숲 어디서나 접근 가능
- **🏆 함수 트로피**: 함수 스코프 내부 변수, 해당 나무에서만 발견
- **🗝️ 블록 열쇠**: let/const 블록 스코프 변수, 특정 구역에서만 유효
- **📜 모듈 두루마리**: 모듈 스코프 변수, 특별한 나무에서만 접근
- **⚡ 동적 번개**: with문이나 eval로 생성된 동적 스코프 변수

### 스테이지 구성
**🟢 Beginner (5 stages)**
1. **전역 스코프 정원**: 가장 넓은 정원에서 전역 변수 보물 수집하기
2. **함수 나무 오두막**: 첫 번째 함수 스코프 나무 탐험과 지역 변수 발견
3. **블록 스코프 동굴**: let/const로 만들어진 블록 스코프 구역 탐험
4. **중첩 나무 마을**: 함수 안에 함수가 있는 2단계 중첩 구조 탐험
5. **기본 스코프 체인**: 간단한 변수 검색 경로 추적하고 이해하기

**🟡 Intermediate (5 stages)**
1. **복잡한 중첩 미궁**: 3-4단계 깊이의 복잡한 중첩 함수 스코프 정복
2. **호이스팅 마법 타워**: 스코프와 호이스팅이 상호작용하는 특별한 지역
3. **모듈 스코프 성**: import/export로 연결된 모듈 간 변수 접근 마스터
4. **위험한 with 늪**: deprecated된 with문의 동적 스코프 체험 (경고와 함께)
5. **정적 vs 동적 전투장**: 컴파일 타임 vs 런타임 스코프 결정 차이점 학습

**🔴 Advanced (5 stages)**
1. **스코프 성능 연구소**: 스코프 체인 최적화와 변수 접근 성능 분석
2. **메모리 스코프 천문대**: 스코프와 메모리 사용량의 상관관계 탐구
3. **실행 컨텍스트 차원문**: 스코프와 실행 컨텍스트의 깊은 연관성 이해
4. **고급 패턴 연금술실**: IIFE, 모듈 패턴, 네임스페이스 등 실무 스코프 패턴
5. **스코프 마스터 시험**: 모든 스코프 개념을 종합한 최종 보스 던전

---

## 11. ⚡ Hoisting Helicopter (호이스팅 헬리콥터)

### 게임 타입: **실시간 물리 시뮬레이션 게임**
- **테마**: 숙련된 헬리콥터 조종사가 되어 JavaScript 선언문들을 올바른 실행 높이로 정밀하게 운반
- **목표**: 호이스팅의 모든 비밀을 마스터하여 완벽한 코드 실행 순서 예측 능력 획득

### 게임플레이
- 고층 건물들이 즐비한 도시 상공에서 다양한 타입의 "선언 화물"들을 운반하는 특수 임무
- 각 화물(var, let, const, function)마다 고유한 "호이스팅 규칙"과 "무게"가 다름
- 플레이어가 헬리콥터를 조종하여 화물을 코드 실행 전 올바른 위치에 배치
- 실시간 "호이스팅 시뮬레이터"로 선언과 할당이 분리되어 움직이는 과정 시각화
- TDZ(Temporal Dead Zone)는 위험한 "금지 비행 구역"으로 표현되어 접근 시 크래시
- 성공적인 호이스팅 시 아름다운 건물 조명 효과, 실패 시 화물 추락과 에러 메시지

### 화물 종류
- **📦 var 화물**: 가벼운 화물, 자동으로 스코프 최상단까지 부상 (undefined 상태)
- **🎁 let 화물**: 중간 무게, TDZ에서 접근 불가능한 특수 화물
- **💎 const 화물**: 무거운 화물, 한 번 배치하면 이동 불가능
- **🚀 function 화물**: 로켓 부스터 장착, 선언과 할당이 함께 호이스팅
- **📋 class 화물**: 고급 화물, let과 유사한 TDZ 특성

### 스테이지 구성
**🟢 Beginner (5 stages)**
1. **var 호이스팅 훈련장**: 기본 var 선언의 호이스팅 동작 체험하기
2. **함수 호이스팅 활주로**: function 선언식의 완전한 호이스팅 이해
3. **선언 vs 할당 분리 작전**: 선언부와 할당부가 다른 시점에 실행되는 과정 학습
4. **undefined vs ReferenceError 구분**: 접근 가능한 undefined와 에러의 차이점 체험
5. **기본 호이스팅 패턴 마스터**: 일반적인 호이스팅 시나리오들 완벽 이해

**🟡 Intermediate (5 stages)**
1. **let/const 호이스팅 특수 임무**: ES6 선언문들의 독특한 호이스팅 동작 마스터
2. **TDZ 위험 지역 통과**: Temporal Dead Zone의 위험성과 활용법 체험
3. **함수 표현식 vs 선언식 대결**: 두 가지 함수 정의 방식의 호이스팅 차이점 학습
4. **클래스 호이스팅 고급 과정**: ES6 클래스의 특별한 호이스팅 규칙 이해
5. **모듈 호이스팅 국제 공항**: import/export 문의 호이스팅과 모듈 로딩 순서

**🔴 Advanced (5 stages)**
1. **복잡한 호이스팅 시나리오 극한 임무**: 중첩된 스코프와 다양한 선언이 섞인 복잡한 상황
2. **호이스팅-스코프 상호작용 연구**: 스코프 체인과 호이스팅이 만나는 고급 패턴 분석
3. **호이스팅 최적화 엔진 룸**: V8 엔진의 호이스팅 최적화 과정과 성능 고려사항
4. **실무 호이스팅 패턴 아카데미**: 실제 프로젝트에서 마주치는 호이스팅 함정과 해결법
5. **호이스팅 디버깅 마스터 클래스**: 호이스팅 관련 버그 진단과 해결 전략 완성

---

## 12. 🎯 This Binding Target (this 바인딩 타겟)

### 게임 타입: **정밀 타겟 슈팅 아케이드**
- **테마**: 세계 최고의 명사수가 되어 변화무쌍한 this 타겟을 정확히 명중시키는 극한의 사격 훈련
- **목표**: this 바인딩의 모든 비밀을 마스터하여 어떤 상황에서든 this가 가리키는 대상을 완벽하게 예측

### 게임플레이
- 거대한 첨단 사격 훈련장에 다양한 형태와 움직임을 가진 타겟들이 등장
- 마법의 화살(this)이 실시간으로 어떤 타겟을 향해 날아가는지 예측하는 것이 핵심
- 플레이어가 코드 상황을 분석하여 올바른 타겟에 조준점을 맞춰야 함
- call, apply, bind는 "타겟 조준경"으로 표현되어 화살의 방향을 인위적으로 조정 가능
- 화살표 함수는 특별한 "고정 화살"로 표현되어 발사 위치의 타겟에 고정
- 정확한 예측 시 타겟 폭발과 점수 획득, 실패 시 빗나간 화살과 감점

### 타겟 종류
- **🌍 글로벌 타겟**: 전역 객체(window/global), 가장 큰 배경 타겟
- **📱 객체 타겟**: 메서드 호출 시의 객체, 중앙의 주요 타겟
- **👤 생성자 타겟**: new로 생성되는 인스턴스, 빛나는 새로운 타겟
- **🎭 이벤트 타겟**: DOM 이벤트 핸들러의 element, 움직이는 동적 타겟
- **🔄 바인딩 타겟**: call/apply/bind로 지정된 객체, 마법으로 이동하는 타겟
- **➡️ 화살표 타겟**: 렉시컬 스코프의 this, 절대 움직이지 않는 고정 타겟

### 스테이지 구성
**🟢 Beginner (5 stages)**
1. **전역 this 기본 사격장**: 가장 기본적인 전역 객체 this 타겟 명중하기
2. **객체 메서드 타겟 연습**: 객체의 메서드에서 this가 해당 객체를 가리키는 패턴 학습
3. **함수 호출 this 분석**: 일반 함수 호출에서 this의 기본 바인딩 이해
4. **생성자 this 신규 타겟**: new 키워드로 생성되는 인스턴스 this 마스터
5. **이벤트 핸들러 this 체험**: DOM 이벤트에서 this가 이벤트 타겟을 가리키는 특성

**🟡 Intermediate (5 stages)**
1. **call/apply/bind 조준경 훈련**: 명시적 this 바인딩으로 타겟 직접 조작하기
2. **화살표 함수 고정 타겟**: 렉시컬 스코프를 유지하는 화살표 함수의 this 특성
3. **중첩 함수 this 미로**: 함수 안의 함수에서 this가 어떻게 변하는지 추적
4. **콜백 함수 this 변신**: 콜백으로 전달될 때 this가 어떻게 변하는지 예측
5. **클래스 메서드 this 현대전**: ES6 클래스 메서드에서의 this 동작 완전 정복

**🔴 Advanced (5 stages)**
1. **복잡한 this 바인딩 극한 사격**: 여러 바인딩 규칙이 복합적으로 적용되는 고난도 시나리오
2. **this-클로저 조합 특수 임무**: 클로저와 this가 함께 사용되는 고급 패턴 마스터
3. **프록시 this 마법 타겟**: Proxy 객체에서 this의 특별한 동작 원리 이해
4. **this 성능 최적화 연구소**: this 바인딩 관련 성능 고려사항과 최적화 기법
5. **실무 this 패턴 마스터 클래스**: 실제 프로젝트에서 자주 마주치는 this 함정과 우회 전략

---

## 13. 🎪 Destructuring Circus (구조분해 서커스)

### 게임 타입: **화려한 퍼즐 & 패턴 매칭 서커스 쇼**
- **테마**: 세계 최고의 서커스단의 단장이 되어 복잡한 데이터 구조를 아름다운 공연으로 분해하고 재배치
- **목표**: 구조분해의 모든 마법을 마스터하여 어떤 복잡한 데이터든 우아하게 해체하고 변수에 할당

### 게임플레이
- 화려한 대형 서커스 텐트에서 다양한 "데이터 공연단"(배열, 객체)이 무대에 등장
- 각 공연단은 고유한 구조와 멤버들을 가지고 있으며, 일부는 깊이 중첩된 복잡한 구성
- 플레이어가 서커스 단장으로서 구조분해 "지휘봉"을 사용하여 공연자들을 적절한 무대 위치에 배치
- 실시간 "구조분해 시뮬레이터"로 데이터가 아름답게 분해되는 과정을 화려한 서커스 공연으로 시각화
- 기본값 설정은 "대역 공연자"로, 나머지 패턴은 "앙코르 공연"으로 표현
- 성공적인 구조분해 시 박수갈채와 폭죽, 실패 시 공연 사고와 관객 야유

### 공연단 종류
- **🎯 배열 곡예단**: 순서가 중요한 공연자들, 인덱스 기반 배치
- **🎭 객체 연극단**: 이름이 있는 배우들, 속성명 기반 캐스팅
- **🤹 중첩 마술단**: 복잡하게 얽힌 다층 구조의 공연단
- **🎨 기본값 백업단**: 주 공연자가 없을 때 대신 무대에 서는 대역들
- **🎪 나머지 앙코르단**: 주요 공연 후 남은 모든 공연자들이 함께 하는 피날레
- **⚡ 동적 변신단**: 실시간으로 역할이 바뀌는 특수 공연단

### 스테이지 구성
**🟢 Beginner (5 stages)**
1. **배열 구조분해 기초 무대**: 단순한 배열을 개별 변수로 분해하는 기본 공연
2. **객체 구조분해 입문 쇼**: 객체의 속성들을 변수로 추출하는 기초 연기
3. **변수명 변경 특별 공연**: 원래 속성명과 다른 변수명으로 할당하는 기법
4. **기본값 설정 안전망**: 값이 없을 때 기본값으로 대체하는 안전한 공연
5. **나머지 패턴 앙코르**: ...rest로 남은 모든 요소를 모으는 피날레 공연

**🟡 Intermediate (5 stages)**
1. **중첩 구조분해 다층 서커스**: 객체 안의 객체를 깊이 분해하는 고난도 공연
2. **함수 매개변수 구조분해 입장권**: 함수 호출 시 매개변수를 바로 분해하는 특별 기법
3. **스왑과 교환 마술쇼**: 두 변수의 값을 구조분해로 바꾸는 마법 같은 공연
4. **동적 속성명 변신술**: 계산된 속성명을 사용한 동적 구조분해 마스터
5. **계산된 속성 고급 연기**: 표현식을 사용한 복잡한 속성 접근 패턴

**🔴 Advanced (5 stages)**
1. **복잡한 중첩 패턴 그랜드 슬램**: 배열과 객체가 복잡하게 얽힌 최고난도 구조분해
2. **성능 최적화 효율성 쇼**: 구조분해의 성능 특성과 최적화 고려사항 마스터
3. **타입스크립트 구조분해 프리미엄**: 타입 안전성을 보장하는 고급 구조분해 패턴
4. **실무 활용 패턴 마스터 클래스**: React props, API 응답 등 실무에서 자주 사용되는 패턴
5. **구조분해 최적화 기법 올림픽**: 메모리 효율성과 가독성을 동시에 만족하는 최고급 기법

---

## 14. 🔄 Array Methods Racing (배열 메서드 레이싱)

### 게임 타입: **고속 레이싱 시뮬레이션 게임**
- **테마**: 세계 최고의 레이싱 드라이버가 되어 각각 고유한 특성을 가진 배열 메서드 슈퍼카들로 경주
- **목표**: 배열 메서드의 모든 특성을 마스터하여 어떤 데이터 처리 상황에서든 최적의 메서드를 선택

### 게임플레이
- 미래형 레이싱 트랙에서 다양한 "배열 메서드 슈퍼카"들이 각자의 특기를 살려 경주
- 각 미션마다 다른 도전 과제(데이터 변환, 필터링, 집계 등)가 주어짐
- 플레이어가 상황에 맞는 최적의 메서드 차량을 선택하고 직접 운전
- 실시간 "성능 모니터"로 메모리 사용량, 실행 시간, 결과 품질을 추적
- 메서드 체이닝은 "터보 부스트"로 표현되어 연속적인 가속 효과
- 올바른 선택 시 트랙 레코드 갱신, 잘못된 선택 시 연료 소모와 시간 지연

### 슈퍼카 종류
- **🏎️ Map Transformer**: 모든 요소를 변환하는 만능 변신차, 안정적인 성능
- **🔍 Filter Selector**: 조건에 맞는 요소만 선별하는 정밀 필터카
- **⚡ Reduce Aggregator**: 모든 데이터를 하나로 집약하는 파워풀한 압축차
- **🔄 ForEach Iterator**: 모든 요소를 순회하는 기본 순찰차, 부작용 특화
- **🎯 Find Hunter**: 첫 번째 조건 만족 요소를 찾는 스피드 헌터
- **✅ Some/Every Checker**: 조건 검사 전문 검증차
- **📊 Sort Organizer**: 정렬 전문 질서정리차
- **✂️ Splice/Slice Modifier**: 배열 수정/복사 전문 정밀 수술차

### 스테이지 구성
**🟢 Beginner (5 stages)**
1. **Map 변환 기초 트랙**: 모든 숫자를 2배로 만드는 단순 변환 레이스
2. **Filter 필터링 코스**: 조건에 맞는 요소만 걸러내는 선별 경주
3. **Reduce 집계 서킷**: 배열의 모든 값을 하나의 결과로 만드는 압축 레이스
4. **ForEach 순회 루프**: 모든 요소에 부작용을 적용하는 순찰 미션
5. **Find 검색 미로**: 첫 번째 조건 만족 요소를 빠르게 찾는 탐색 경주

**🟡 Intermediate (5 stages)**
1. **메서드 체이닝 터보 트랙**: 여러 메서드를 연결하여 복합 작업 수행하기
2. **Some/Every 검증 서킷**: 조건 만족 여부를 빠르게 판단하는 논리 레이스
3. **Sort 정렬 올림픽**: 다양한 기준으로 배열을 정렬하는 질서 경주
4. **Splice vs Slice 정밀 코스**: 원본 수정 vs 복사본 생성의 차이점 마스터
5. **성능 비교 분석 랩**: 같은 결과를 다른 방법으로 달성하는 효율성 대결

**🔴 Advanced (5 stages)**
1. **복잡한 체이닝 최적화 그랑프리**: 긴 메서드 체인을 성능 최적화하는 고급 레이스
2. **커스텀 메서드 구현 워크숍**: 내장 메서드의 내부 동작을 직접 구현해보는 엔지니어링 챌린지
3. **함수형 프로그래밍 패턴 마스터**: map/filter/reduce를 조합한 함수형 패러다임 완성
4. **대용량 데이터 처리 익스트림**: 수백만 개 요소를 효율적으로 처리하는 스케일링 챌린지
5. **실무 최적화 사례 올림픽**: 실제 프로젝트에서 마주치는 복잡한 배열 처리 시나리오 해결

---

## 15. 🎲 Modules Marketplace (모듈 마켓플레이스)

### 게임 타입: **글로벌 무역 경영 시뮬레이션**
- **테마**: 세계적인 무역상이 되어 JavaScript 모듈들을 거래하는 거대한 글로벌 마켓플레이스 운영
- **목표**: 모듈 시스템의 모든 비밀을 마스터하여 효율적이고 확장 가능한 코드 아키텍처 구축

### 게임플레이
- 전 세계에 퍼져있는 다양한 "코드 상점"들이 네트워크로 연결된 거대한 디지털 시장
- 각 상점(모듈)은 고유한 "상품"(함수, 클래스, 상수)들을 생산하고 판매
- 플레이어가 무역상으로서 필요한 상품을 적절한 상점에서 import하고, 자신의 상품을 export
- 실시간 "의존성 네트워크 시각화"로 모듈 간의 복잡한 관계를 거미줄 형태로 표시
- 순환 의존성은 "무역 교착 상태"로 표현되어 해결하지 않으면 시장 마비
- 성공적인 거래 시 수익과 평판 상승, 잘못된 의존성 시 시장 충돌과 손실

### 상점 종류
- **🏪 기본 수출 상점**: default export로 주력 상품 하나를 대량 판매
- **🏬 명품 전문점**: named export로 여러 고급 상품을 개별적으로 판매
- **🏭 생산 공장**: 다른 모듈의 원료를 가공하여 새로운 상품 생산
- **📦 물류 센터**: re-export로 여러 상점의 상품을 중계 유통
- **🌐 글로벌 체인점**: 동적 import로 필요할 때만 상품을 주문하는 효율적 운영
- **🔄 순환 거래소**: 서로 의존하는 상점들이 만드는 복잡한 거래 구조

### 스테이지 구성
**🟢 Beginner (5 stages)**
1. **기본 Import/Export 무역 학교**: 가장 기본적인 모듈 거래 방법 학습
2. **Default Export 전문 매장**: 하나의 주력 상품을 기본으로 수출하는 단순한 비즈니스 모델
3. **Named Export 명품관**: 여러 개의 이름 있는 상품을 개별적으로 판매하는 전략
4. **모듈 경로 내비게이션**: 상대 경로와 절대 경로로 올바른 상점 찾아가기
5. **브라우저 모듈 직판장**: HTML에서 직접 ES6 모듈을 로드하는 현대식 판매 방법

**🟡 Intermediate (5 stages)**
1. **동적 Import 주문형 서비스**: 필요할 때만 모듈을 로드하는 효율적 무역 전략
2. **Re-export 유통업 마스터**: 다른 모듈의 상품을 중개하여 재판매하는 유통 비즈니스
3. **모듈 번들링 물류 센터**: Webpack, Rollup 등으로 여러 모듈을 하나로 패키징
4. **CommonJS vs ES Modules 국제 무역**: 두 가지 모듈 시스템의 차이점과 상호 운용성
5. **트리 쉐이킹 재고 최적화**: 사용하지 않는 코드를 제거하여 번들 크기 최적화

**🔴 Advanced (5 stages)**
1. **순환 의존성 해결 전문가**: 복잡하게 얽힌 모듈 의존성 문제를 해결하는 고급 전략
2. **모듈 페더레이션 글로벌 네트워크**: 마이크로 프론트엔드를 위한 모듈 공유 아키텍처
3. **성능 최적화 효율성 컨설팅**: 모듈 로딩 성능과 번들 크기 최적화 마스터
4. **마이크로 프론트엔드 아키텍트**: 독립적인 프론트엔드 모듈들을 조합하는 현대적 설계
5. **실무 아키텍처 패턴 올림픽**: 대규모 프로젝트에서 검증된 모듈 구성 패턴 완성

---

## 16. 🎨 Template Literal Art (템플릿 리터럴 아트)

### 게임 타입: **창의적 디지털 아트 스튜디오**
- **테마**: 세계적인 디지털 아티스트가 되어 템플릿 리터럴이라는 마법의 붓으로 역동적이고 아름다운 문자열 아트 창작
- **목표**: 템플릿 리터럴의 모든 표현 기법을 마스터하여 동적이고 강력한 문자열 생성 예술가 되기

### 게임플레이
- 현대적인 디지털 아트 스튜디오에서 "문자열 캔버스"에 다양한 데이터와 표현식을 조합
- 백틱(`)으로 둘러싸인 특별한 "마법 캔버스"에서 ${} 보간 구문으로 생동감 있는 작품 창작
- 변수, 함수 호출, 복잡한 표현식들이 실시간으로 캔버스에 그려지는 과정 시각화
- 태그드 템플릿은 "특수 효과 브러시"로 표현되어 문자열에 고급 처리 효과 적용
- 멀티라인 문자열로 ASCII 아트나 복잡한 템플릿 구조 생성
- 성공적인 작품 완성 시 갤러리 전시와 찬사, 문법 오류 시 캔버스 깨짐 효과

### 아트 도구 종류
- **✏️ 기본 보간 펜슬**: ${variable}로 변수 값을 자연스럽게 문자열에 삽입
- **🖌️ 표현식 브러시**: ${expression}로 계산 결과를 실시간으로 그리기
- **📏 멀티라인 캔버스**: 여러 줄에 걸친 복잡한 템플릿 구조 작업
- **🎭 태그 함수 특수 효과**: 문자열 처리를 커스터마이징하는 고급 도구
- **🌈 조건부 컬러링**: 조건에 따라 다른 문자열을 생성하는 동적 페인팅
- **🔄 반복 패턴 스탬프**: 배열이나 객체를 순회하며 반복 패턴 생성

### 스테이지 구성
**🟢 Beginner (5 stages)**
1. **기본 문자열 보간 아트**: 간단한 변수를 문자열에 삽입하는 기초 기법 마스터
2. **표현식 삽입 창작**: 계산식과 함수 호출 결과를 문자열에 동적으로 포함시키기
3. **멀티라인 문자열 조각**: 여러 줄에 걸친 아름다운 템플릿 구조 창작하기
4. **이스케이프 처리 기법**: 특수 문자와 백틱을 안전하게 문자열에 포함시키는 방법
5. **기본 포맷팅 스튜디오**: 숫자, 날짜 등을 보기 좋게 포맷팅하는 기초 기법

**🟡 Intermediate (5 stages)**
1. **태그드 템플릿 특수 효과**: 커스텀 태그 함수로 문자열을 가공하는 고급 기법
2. **조건부 문자열 생성 마법**: if/else 로직을 활용한 동적 문자열 생성 아트
3. **반복 패턴 생성 워크숍**: 배열과 객체를 순회하며 반복적인 템플릿 패턴 창작
4. **HTML 템플릿 아키텍트**: 동적 HTML 생성을 위한 템플릿 리터럴 활용법
5. **CSS 동적 생성 디자이너**: JavaScript 데이터를 기반으로 CSS 스타일 동적 생성

**🔴 Advanced (5 stages)**
1. **고급 태그드 템플릿 마스터**: 복잡한 문자열 파싱과 변환을 수행하는 전문가급 기법
2. **보안 고려사항 방어벽**: XSS 공격을 방지하는 안전한 템플릿 리터럴 사용법
3. **성능 최적화 엔진**: 대량의 템플릿 처리 시 성능을 최적화하는 고급 전략
4. **국제화 패턴 글로벌 아트**: 다국어 지원을 위한 템플릿 리터럴 국제화 기법
5. **템플릿 엔진 구현 아키텍트**: 나만의 템플릿 엔진을 처음부터 구현하는 최고급 프로젝트

---

## 17. 🔧 Error Handling Hospital (에러 처리 병원)

### 게임 타입: **실시간 의료 응급실 시뮬레이션**
- **테마**: 세계 최고의 응급의학과 전문의가 되어 다양한 "코드 에러 환자"들을 신속하고 정확하게 진단하고 치료
- **목표**: 에러 처리의 모든 의학적 기법을 마스터하여 어떤 프로그램 응급상황에서도 완벽한 복구 능력 획득

### 게임플레이
- 24시간 돌아가는 초현대식 "에러 응급병원"에 다양한 중증도의 에러 환자들이 끊임없이 도착
- 각 환자(에러)마다 고유한 "증상"(에러 타입)과 "발병 원인"(에러 발생 지점)이 다름
- 플레이어가 응급의로서 신속한 "에러 진단"과 적절한 "try/catch/finally 처방"을 내려야 함
- 실시간 "에러 모니터링 시스템"으로 환자 상태와 치료 진행 과정을 추적
- 에러 전파는 "감염 확산"으로, 글로벌 에러는 "병원 전체 비상사태"로 표현
- 성공적인 치료 시 환자 회복과 평판 상승, 치료 실패 시 프로그램 크래시와 의료사고

### 환자(에러) 종류
- **🤒 구문 에러 환자**: SyntaxError, 코드 문법이 잘못된 급성 환자
- **🩹 참조 에러 환자**: ReferenceError, 존재하지 않는 변수를 찾는 경증 환자
- **🤕 타입 에러 환자**: TypeError, 잘못된 타입 사용으로 인한 외상 환자
- **💊 범위 에러 환자**: RangeError, 유효 범위를 벗어난 만성 질환
- **🚨 비동기 에러 환자**: Promise rejection, async/await 관련 중증 환자
- **💀 크리티컬 환자**: 시스템 전체를 위험에 빠뜨리는 치명적 에러

### 스테이지 구성
**🟢 Beginner (5 stages)**
1. **기본 Try/Catch 응급처치**: 가장 기본적인 에러 포착과 처리 방법 마스터
2. **Error 객체 진단학**: 에러 객체의 구조와 정보를 분석하는 진단 기법
3. **Finally 블록 후속 치료**: 에러 발생 여부와 관계없이 실행되는 필수 후처리
4. **에러 타입 감별 진단**: 다양한 에러 타입을 정확히 구분하고 분류하는 전문 기술
5. **기본 에러 메시지 처방전**: 사용자에게 적절한 에러 메시지를 제공하는 커뮤니케이션

**🟡 Intermediate (5 stages)**
1. **커스텀 에러 클래스 전문의**: 프로젝트에 특화된 에러 타입을 직접 만드는 고급 기법
2. **에러 전파와 버블링 감염학**: 에러가 어떻게 상위로 전파되는지 이해하고 제어
3. **Async/Await 에러 처리 전문과**: 비동기 코드에서의 특수한 에러 처리 패턴
4. **Promise 에러 처리 중환자실**: .catch()와 try/catch의 적절한 조합 사용법
5. **에러 로깅 전략 의무기록**: 에러 발생 상황을 체계적으로 기록하고 분석하는 시스템

**🔴 Advanced (5 stages)**
1. **글로벌 에러 핸들러 병원장**: 애플리케이션 전체의 에러를 통합 관리하는 최고 책임자
2. **에러 복구 패턴 재활의학**: 에러 발생 후 시스템을 안전하게 복구하는 고급 전략
3. **모니터링과 알림 시스템 관리**: 실시간 에러 감지와 자동 알림 시스템 구축
4. **사용자 경험 고려 환자 케어**: 에러 상황에서도 최적의 사용자 경험을 제공하는 방법
5. **실무 에러 처리 전략 의학 연구**: 대규모 프로덕션 환경에서 검증된 에러 처리 패턴

---

## 18. 🎯 WeakMap/WeakSet Vault (약한 참조 금고)

### 게임 타입: **첨단 사이버 보안 스파이 시뮬레이션**
- **테마**: 최첨단 디지털 요새의 보안관이 되어 "약한 참조" 기술로 완벽한 보안 시설 운영
- **목표**: WeakMap/WeakSet의 독특한 특성을 완전히 마스터하여 메모리 효율적이고 보안성이 뛰어난 시스템 구축

### 게임플레이
- 미래형 사이버 보안 시설에서 다양한 "디지털 자산"(객체)들을 안전하게 관리
- 각 자산마다 "보안 키"(WeakMap/WeakSet)가 할당되어 자산이 소멸되면 키도 자동으로 사라짐
- 플레이어가 보안관으로서 일반 Map/Set의 "강한 참조"와 WeakMap/WeakSet의 "약한 참조" 차이를 활용
- 실시간 "메모리 스캐너"로 가비지 컬렉션 과정과 자동 정리 과정을 시각화
- 보안 키가 사라진 자산에 접근 시도하면 "보안 침해 알림"과 접근 거부
- 메모리 누수 없는 완벽한 보안 시스템 구축 시 최고 보안 등급 달성

### 보안 도구 종류
- **🗝️ WeakMap 마스터키**: 객체를 키로 사용하는 특별한 보안 저장소
- **🔐 WeakSet 접근 허가증**: 객체들의 집합을 약한 참조로 관리하는 멤버십 시스템
- **💎 강한 참조 다이아몬드**: 일반 Map/Set, 영구적이지만 메모리 누수 위험
- **🌪️ 가비지 컬렉터**: 참조가 끊어진 객체들을 자동으로 청소하는 시스템
- **📊 메모리 프로파일러**: 메모리 사용량과 참조 관계를 실시간 모니터링
- **🚫 프라이빗 데이터 금고**: 외부에서 접근 불가능한 비밀 정보 저장소

### 스테이지 구성
**🟢 Beginner (5 stages)**
1. **WeakMap 기본 보안 교육**: 객체를 키로 사용하는 특별한 맵의 기초 사용법
2. **WeakSet 멤버십 관리**: 객체들의 집합을 약한 참조로 관리하는 기본 기법
3. **Map vs WeakMap 비교 분석**: 강한 참조와 약한 참조의 근본적인 차이점 체험
4. **가비지 컬렉션 체험장**: 참조가 끊어진 객체가 자동으로 정리되는 과정 관찰
5. **기본 활용 패턴 훈련소**: WeakMap/WeakSet의 일반적인 사용 사례 학습

**🟡 Intermediate (5 stages)**
1. **프라이빗 데이터 저장 금고**: 클래스 인스턴스의 비공개 데이터를 안전하게 저장
2. **캐시 시스템 구현 연구소**: 메모리 누수 없는 효율적인 캐싱 메커니즘 구축
3. **DOM 노드와 WeakMap 연동**: 웹 페이지 요소와 관련 데이터를 안전하게 연결
4. **이벤트 핸들러 관리 시스템**: DOM 요소가 제거되면 자동으로 정리되는 이벤트 관리
5. **메타데이터 저장 아카이브**: 객체에 대한 추가 정보를 외부에서 접근 불가능하게 저장

**🔴 Advanced (5 stages)**
1. **고급 디자인 패턴 아키텍처**: Observer 패턴, Decorator 패턴 등에서 WeakMap 활용
2. **성능 최적화 연구소**: WeakMap/WeakSet을 활용한 고성능 애플리케이션 설계
3. **메모리 프로파일링 전문가**: 복잡한 애플리케이션의 메모리 사용 패턴 분석과 최적화
4. **실무 활용 사례 마스터 클래스**: 대규모 프로젝트에서 검증된 WeakMap/WeakSet 활용법
5. **아키텍처 설계 최고 책임자**: 메모리 효율성과 보안성을 모두 만족하는 시스템 아키텍처 완성

---

## 게임 공통 기능

### 진행도 시스템
- 각 게임당 10-15레벨
- 별점 시스템 (1-3개별)
- 전체 진행률 트래킹

### 게임 안내 모달 시스템
**필수 구현 요소**: 모든 새로운 게임은 반드시 게임 안내 모달을 포함해야 함

#### 구성 요소
1. **게임 소개 단계**: 게임의 테마와 목표를 실제 게임 화면과 싱크된 비주얼로 설명
2. **게임 목표 단계**: 단계별 학습 목표와 진행 방식을 명확히 제시
3. **게임 방법 단계**: 실제 게임 화면의 축소 버전으로 조작 방법과 UI 설명

#### 디자인 원칙
- **게임 화면 싱크**: 안내 모달의 비주얼이 실제 게임 화면과 일치하도록 구현
- **라이트 테마 대비**: 모든 텍스트와 버튼이 라이트 테마에서 명확히 보이도록 색상 대비 준수
- **점진적 공개**: 각 단계별로 핵심 개념을 순차적으로 설명
- **상호작용 미리보기**: 드래그 앤 드롭, 클릭 등 주요 상호작용을 미니 데모로 제공

#### 기술 구현
```typescript
// GameGuideModal.tsx 표준 구조
interface GameGuideModalProps {
  isOpen: boolean
  onClose: () => void
  onStart: () => void
}

// 3단계 구성
const guideSteps = [
  { 
    title: "게임 소개",
    visual: <GameThemePreview />,  // 실제 게임 화면과 동일한 스타일
    content: "게임 테마와 목표 설명"
  },
  {
    title: "게임 목표", 
    visual: <StepByStepGuide />,   // 단계별 진행 방식
    content: "학습 목표와 진행 방식"
  },
  {
    title: "게임 방법",
    visual: <InteractiveDemo />,   // 실제 게임 UI의 축소 버전
    content: "조작 방법과 UI 설명"
  }
]
```

#### 현재 구현 상태
- ✅ **CallStack Library**: 완전 구현됨 (책장 디자인 싱크, 라이트 테마 대비 완료)
- ❌ **Closure Cave**: 안내 모달 없음 (향후 추가 필요)
- ❌ **기타 게임들**: 개발 시 필수 구현 예정

### 힌트 시스템
- 단계별 힌트 제공
- 코드 실행 과정 시각화
- MDN 문서 연결

### 코드 에디터
- 구문 강조
- 자동 완성
- 실시간 오류 검사

### 시각화 엔진
- CSS 애니메이션 기반
- 단계별 실행 과정 표시
- 인터랙티브 요소

## 기술 스택

### 프론트엔드
- **바닐라 JavaScript**: 게임 로직
- **CSS3 + Animations**: 시각화
- **HTML5**: 마크업
- **CodeMirror**: 코드 에디터

### 구조
```
📁 js-concept-games/
├── 📁 games/
│   ├── 📁 closure-cave/
│   ├── 📁 callstack-tower/
│   ├── 📁 promise-rocket/
│   └── ...
├── 📁 shared/
│   ├── 📄 game-engine.js
│   ├── 📄 visualizer.js
│   └── 📄 code-runner.js
└── 📄 index.html
```

### 개발 단계
1. **Week 1-2**: 게임 엔진과 공통 컴포넌트 개발
2. **Week 3-4**: Closure Cave 프로토타입 구현
3. **Week 5-6**: CallStack Tower, Promise Rocket 추가
4. **Week 7-8**: 나머지 게임들 구현
5. **Week 9-10**: 통합, 테스트, 최적화